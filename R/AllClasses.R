#-------------------------GeneGroupsObject---------------------------

#' S4 class for Gene Groups
#' @name genegroups_class
#'
#' @description This function splits gene list into quantiles and generates all unions of neighbouring quantiles.
#'              It takes dataframe with genes ID's and fold values, number of quantiles
#'              and logical variable which must set to TRUE if fold values are presented in logarithmic scale,
#'              otherwise it must be set to FALSE value (TRUE by default) as parameters.
#'
#' @section Constructor:
#' \code{GeneGroups(inputtable, quannumber, logfold)}, where:
#' \describe{
#' \item{}{\code{inputtable} - dataframe contains initial set of genes gene ID's in the first row
#'             and corresponding fold change values in the second row}
#' \item{}{\code{quannumber} - number of quantiles (e.g. 2,3,4...)}
#' \item{}{\code{logfold} - TRUE if fold values are presented in log scale, otherwise is FALSE}
#' }
#' @section Accessors:
#' In the code examples below \code{object} is an object of GeneGroups class
#' \describe{
#' \item{}{\code{getGroups(object)} - returns list of gene sets for each
#' quatile and all combinations}
#' \item{}{\code{getWholeIntName(object)} - returns name of the interval
#' containing all differentially expressed genes}
#' \item{}{\code{getQuanNumber(object)} - returns number of quantiles}
#' \item{}{\code{getIntNames(object)} - returns vector of intervals names}
#' \item{}{\code{getRegType(object)} - returns regulation type}
#' }
#' @examples
#' # split initial gene set into quantiles
#' gene_groups <- GeneGroups(degenes, 6)
#' # get list of gene sets for each quatile and all combinations
#' getGroups(gene_groups)
#' # get name of the interval containing all differentially expressed genes
#' getWholeIntName(gene_groups)
#' # get number of quantiles
#' getQuanNumber(gene_groups)
#' # get vector of intervals names
#' getIntNames(gene_groups)
#' # get regulation type
#' getRegType(gene_groups)
setClass(

  "GeneGroups",

  slots = c(
    inputtable = "data.frame",
    logfold = "logical",
    quannumber = "numeric",
    groups = "list",
    intnames = "character",
    wholeintname = "character",
    regtype = "character"
  ),

  prototype = list(
    logfold = TRUE
  )

)

# Constructor for GeneGroups S4 class
#' @rdname genegroups_class
#' @export
#' @importFrom methods new
GeneGroups <- function(inputtable, quannumber, ...) {
  obj <- new(
    "GeneGroups",
    inputtable = inputtable,
    quannumber = quannumber,
    ...
  )
  return(divToGroups(obj))
}


#-------------------------AnnotationObject---------------------------

# Abstract S4 class for FuncAnnotGroups object
##############################PARAMS################################
# genegroups GeneGroups. - object of GeneGroups class
# bggenes character. - vector contains background set of genes
# slot resultlist list. - list with filenames as keys and annotaton
#                         data frames as values
# slot padjmethod character. - method for multiple testing correction
# qitborder numeric. - minimal number of genes annotated to a term
#                      (1 by default)
# wholeintname character. - name of the DEG interval (initial set of genes)
setClass(

  "FuncAnnotGroups",

  slots = c(
    genegroups = "GeneGroups",
    bggenes = "character",
    resultlist = "list",
    padjmethod = "character",
    qitborder = "numeric",
    wholeintname = "character"
  ),

  validity = function(object) {
    if (!object@padjmethod %in% p.adjust.methods) {
      return("Unknown multiple testing correction method.
             Choose adjustment method from p.adjust.methods")
    }
    return(TRUE)
    },

  prototype = list(
    bggenes = character(0),
    padjmethod = "BH",
    qitborder = 1
  )

)


#-------------------------Annotation Object for topGO---------------------------
#' S4 class for FuncAnnotGroupsTopGO object
#' @name fagroupstopgo_class
#' @description This function conducts functional enrichment analysis for sets of genes generated by
#' \code{\link{GeneGroups}} function.
#' @section Constructor:
#' \code{FuncAnnotGroupsTopGO(groups, namespace, GO2genes, annot, bggenes, ...)}, where:
#' \describe{
#' \item{}{\code{groups} - object of \code{\link{GeneGroups}} class}
#' \item{}{\code{namespace} - character string specifing GO namespace ("BP", "MF" or "CC")}
#' \item{}{\code{GO2genes} - Use if \code{mapping} argument is set to "custom".Can be generated by \code{\link{GAFReader}}.
#' From TopGO manual: named list of character vectors. The list names are GO identifiers. For each GO the character vector
#' contains the genes identifiers which are mapped to it. Only the most specific annotations are required.}
#' \item{}{\code{annot} - from TopGO manual: These functions are used to compile a list of GO terms such that each
#' element in the list is a character vector containing all the gene identifiers that are mapped to the respective GO term.}
#' \item{}{\code{bggenes} - vector contains background set of genes}
#' \item{}{ ... - other parameters:}
#' \describe{
#' \item{}{\code{genesannot} - minimal number of genes annotated to a term in the annotation. 1 by default}
#' \item{}{\code{algorithm} - from TopGO manual: character string specifing which algorithm to use.
#' The algorithms are shown by the topGO whichAlgorithms() function. "classic" by default}
#' \item{}{\code{statistic} - from TopGO manual: character string specifing which test to use.
#' The statistical tests are shown by the topGO whichTests() function. "fisher" by default}
#' \item{}{\code{mapping} - from TopGO manual: character string specifieng the name of the Bioconductor package containing
#' the gene mappings for a specific organism. For example: mapping = "org.Hs.eg.db". "custom" by default}
#' \item{}{\code{ID} - from TopGO manual: character string specifing the gene identifier to use.
#' Currently only the following identifiers can be used: c("entrez", "genbank", "alias", "ensembl", "symbol",     "genename", "unigene")}
#' }
#' }
#' @section Accessors:
#' In the code examples below \code{object} is an object of FuncAnnotGroupsTopGO class
#' \describe{
#' \item{}{\code{getResultList(object)} - returns list of functional annotation result tables}
#' }
#' @examples
#' \dontrun{
#' # read .gaf file (in this example gaf file with annotation for \emph{A.thaliana} is used)
#' library(topGO)
#' gaf_path <- system.file("extdata", "gene_association.tair.lzma",
#'                          package = "FoldGO", mustWork = TRUE)
#' # read gaf file and convert annoitation in the list format
#' # contains GO term id's as keys and Gene ID's as values
#' gaf <- GAFReader(file = gaf_path, geneid_col = 10)
#' gaf_list <- convertToList(gaf)
#' annotobj <- FuncAnnotGroupsTopGO(up_groups,"BP", GO2genes = gaf_list,
#'                                  annot = topGO::annFUN.GO2genes,
#'                                  bggenes = bggenes, padjmethod = "BH",
#'                                  qitborder = 10, genesannot = 1)
#'
#' # get results of functional enrichment analysis in a tabular form:
#' getResultList(annotobj)
#' }
setClass(

  "FuncAnnotGroupsTopGO",

  slots = c(
    namespace = "character",
    genesannot = "numeric",
    algorithm = "character",
    statistic = "character",
    annot = "function",
    GO2genes = "list",
    mapping = "character",
    ID = "character"
  ),

  prototype = list(
    genesannot = 1,
    algorithm = "classic",
    statistic = "fisher",
    annot = topGO::annFUN,
    GO2genes = list(0),
    mapping = "custom",
    ID = character(0)
  ),

  validity = function(object){
    if (!object@namespace %in% c("BP", "MF", "CC")) {
      return("Unknown namespace. Choose one of the following: MF, CC, BP")
    }
    return(TRUE)
  },

  contains = "FuncAnnotGroups"

)

# Constructor for FuncAnnotGroupsTopGO S4 class
#' @rdname fagroupstopgo_class
#' @import topGO
#' @importFrom methods new
#' @importFrom stats p.adjust
#' @export
FuncAnnotGroupsTopGO <- function(genegroups, namespace, ...) {

  if (!requireNamespace("topGO", quietly = TRUE)) {
    stop("topGO package needed for this function to work. Please install it.",
         call. = FALSE)
  }

  obj <- new(
    "FuncAnnotGroupsTopGO",
    genegroups = genegroups,
    namespace = namespace,
    ...
  )

  obj@wholeintname <- getWholeIntName(genegroups)

  obj <- runFuncAnnotTest(obj)
  return(obj)
}

#-------------------------AnnotationReaderObject---------------------

#--------Abstract Reader--------------
#  Abstract S4 class for AnnotationReader object
##############################PARAMS################################
# file character. - full path to annotation file
# annotation data.frame. - dataframe contains annotation
setClass(

  "AnnotationReader",

  slots = c(
    file = "character",
    annotation = "data.frame"
  )

)

#-------GAF format reader-------------
#' S4 class for GAFReader object
#' @name gafreader_class
#' @description Parser for annotation presented in GAF file format (.gaf).
#' GAFReader function returns object which contains as a dataframe annotation
#' as it presented in initial file. Via GAFReader accessor method one can retrieve
#' annotations as list GO term id's as keys and Gene ID's as values and version of file (see Accessors section).
#'
#' @section Constructor:
#' \code{GAFReader(file = gaf_path, geneid_col = 10)}, where:
#' \describe{
#' \item{}{\code{file} - full path to annotation file}
#' \item{}{\code{geneid_col} - index of column with Gene ID (2 by default)}
#' }
#'
#' @section Accessors:
#' In the code examples below \code{object} is an object of GAFReader class
#' \describe{
#' \item{}{\code{getVersion(object)} - returns version of GAF file}
#' \item{}{\code{getAnnotation(object)} - returns annotation from GAF file}
#' }
#' @section Methods:
#' In the code examples below \code{object} is an object of GAFReader class
#' \describe{
#' \item{}{\code{convertToList(object)} - Convert GAF format type annotation to list
#' contains GO term id's as keys and Gene ID's as values}
#' }
#' @examples
#' # read .gaf file (in this example gaf file with annotation for \emph{A.thaliana} is used)
#' gaf_path <- system.file("extdata", "gene_association.tair.lzma",
#'                          package = "FoldGO", mustWork = TRUE)
#' gaf <- GAFReader(file = gaf_path, geneid_col = 10)
#' # get version of file
#' getVersion(gaf)
#' # get annotations in tabular format
#' getAnnotation(gaf)
#' # get annoitation in the list format contains GO term id's as keys and Gene ID's as values
#' # which can be used by \code{\link{FuncAnnotGroupsTopGO}} function.
#' #
#' convertToList(gaf)
setClass(

  "GAFReader",

  slots = c(
    version = "character",
    info = "character",
    geneid_col = "numeric"
  ),

  prototype = list(
    geneid_col = 2
  ),

  contains = "AnnotationReader"

)

# GAFReader class constructor
#' @export
#' @importFrom methods new
#' @rdname gafreader_class
GAFReader <- function(file, ...) {
  obj <- new(
    "GAFReader",
    file = file,
    ...
  )
  return(read(obj))
}


#-------------------------FoldSpecTestObject-------------------------

#' FoldSpecTest S4 class
#' @name foldspectest_class
#'
#' @description FoldSpecTest object calculates test on fold-specificity and stores all resulting data needed for further analysis.
#' It takes object which is instance of subclass of AnnotGroups class (e.g. FuncAnnotGroupsTopGO class) as a minimal set of input parameters.
#' For more details see Constructor section.
#'
#' @section Constructor:
#' \code{FoldSpecTest(annotgroups, fdrstep1, fdrstep2, padjmethod, fisher_alternative)}, where:
#' \describe{
#' \item{}{\code{annotgroups} - object of FuncAnnotGroups class}
#' \item{}{\code{fdrstep1} - FDR threshold for 1 step of fold-specificty recognition procedure}
#' \item{}{\code{fdrstep2} - FDR threshold for 2 step of fold-specificty recognition procedure}
#' \item{}{\code{padjmethod} - method for multiple testing correction (to see all possible methods print: p.adjust.methods)
#' Benjamini-Hochberg by default}
#' \item{}{\code{fisher_alternative} - indicates the alternative hypothesis and must be one of "two.sided", "greater" or "less".
#' You can specify just the initial letter. Only used in the 2 by 2 case.}
#' }
#' @section Accessors:
#' In the code examples below \code{object} is an object of FoldSpecTest class
#' \describe{
#' \item{}{\code{getFStable(object)} - returns dataframe with fold-change-specific terms and related data}
#' \item{}{\code{getNFStable(object)} - returns dataframe with not fold-change-specific terms and related data}
#' \item{}{\code{getResultTable(object)} - returns dataframe with both fold-change-specific and not fold-change-specific terms}
#' \item{}{\code{getWholeIntName(object)} - returns name of largest fold-change interval (DEGs interval)}
#' }
#' @examples
#' # FoldSpecTest function requires only object of FuncAnnotGroups class as a
#' # minimal set of parameters. In the example up_annotobj is an object of FuncAnnotGroups class
#' # compiled from lists of up-regulated genes from rna-seq experiment on auxin treatment
#' # of Arabidopsis thaliana roots [FoldGO::up_annotobj].
#' FoldSpecTest(up_annotobj)
#'
#' # FoldSpecTest function with custom parameters
#' fs_up <- FoldSpecTest(up_annotobj, fdrstep1 = 0.2, fdrstep2 = 0.01, padjmethod = "BY")
#'
#' # get dataframe with fold-change-specific terms
#' getFStable(fs_up)
#'
#' # get dataframe with not fold-change-specific terms
#' getNFStable(fs_up)
#'
#' # get dataframe with both fold-change-specific and not fold-change-specific terms
#' getResultTable(fs_up)
#'
#' # get name of largest fold-change interval (DEGs interval)
#' getWholeIntName(fs_up)
setClass(

  "FoldSpecTest",

  slots = c(
    fstable = "data.frame",
    nfstable = "data.frame",
    result_table = "data.frame",
    annotgroups = "FuncAnnotGroups",
    wholeintname = "character",
    padjmethod = "character",
    fdrstep1 = "numeric",
    fdrstep2 = "numeric",
    fisher_alternative = "character"
  ),

  validity = function(object){
    if (!object@padjmethod %in% p.adjust.methods) {
      return("Unknown multiple testing correction method.
             Choose adjustment method from p.adjust.methods")
    }

    if (!object@fisher_alternative %in% c("greater", "less", "two.sided", "g", "l", "t")){
      return("Wrong fisher exact test alternative.
             Choose one of the following: greater, less, two.sided or shortened version: g, l, t")
    }

    if (!requireNamespace("tidyr", quietly = TRUE)) {
      stop("tidyr package needed for this function to work. Please install it.",
           call. = FALSE)
    }

    return(TRUE)
    },

  prototype = list(
    padjmethod = "BH",
    fdrstep1 = 1,
    fdrstep2 = 0.05,
    fisher_alternative = "greater"
  )

)

# FoldSpecTest class constructor
#' @export
#' @importFrom methods new
#' @rdname foldspectest_class
FoldSpecTest <- function(annotgroups, ...) {
  obj <- new(
    "FoldSpecTest",
    annotgroups = annotgroups,
    wholeintname = annotgroups@wholeintname,
    ...
  )
  obj <- calcFSsignificance(obj)
  obj <- findFSterms(obj)
  return(obj)
}
