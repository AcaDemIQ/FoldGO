---
title: "FoldGO: a tool for fold-change-specific functional enrichment analysis"
author: "Daniil Wiebe"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{FoldGO: a tool for fold-change-specific functional enrichment analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Typical scenario of transcriptome data analysis is identification of differentially expressed genes (DEGs), those with significant changes in the number of transcripts (fold-change), and functional enrichment analysis of DEGs lists using Gene Ontology. Classical gene set enrichment analysis ignores the difference in the fold-changes that lead to loss of valuable information. FoldGO method created to identify the GO terms significantly overrepresented for the genes responded to the factor within a narrow fold-change-interval. 
FoldGO processes the DEGs list in three steps:
At the first step, FoldGO sorts the genes by their fold-change values, subdivides them into gene sets of equal size (quantiles) and generates the gene sets for all combinations of the neighboring quantiles, including the whole lists of up-regulated or down-regulated genes.
On the second step, FoldGO generates the list of GO terms annotated to at least one differentially expressed gene (DEG). Optionally, GO terms significantly enriched in the DEGs annotation can be selected at this step.
On the third step, FoldGO performs enrichment analysis for all selected GO terms and for all gene sublists. FoldGO measures the bias in the portion of the genes responded fold-change-specifically versus whole DEGs for the genes associated with a GO term or the background. If the result of the test is significant, such GO terms are considered as fold-change-specific.
See an example of the  FoldGO performance in the analysis of the transcriptome data on expression changes of Arabidopsis thaliana genes in response to plant hormone auxin treatment (Omelyanchuk et al., Nat Sci Rep, 2017).

## Workflow

FoldGO pipeline consists of three steps:

* gene sublists generation;
* GO terms preselection (optional);
* fold-change-specific enrichment analysis.

As input data the algorithm uses the tables for up- and down-regulated genes that contain Gene IDs and their fold-change values:

| GeneID | fold-change |
|:------|:----:|
|AT3G65420|3.6|
|AT1G78450|1.5|
|AT2G66890|2.1|
|...|

First, one have to separate initial set of genes in to quantiles and generate unions of all neighbouring quantiles. For example we 
will use built-in data derived from experiment on auxin treatment of Arabidopsis thaliana roots

```{r groups, warning = FALSE, message = FALSE}
devtools::load_all(".")
knitr::kable(head(degenes))
up_groups <- GeneGroups(degenes, quannumber=6)
```
On the next step we will conduct functional enrichment analysis of generated groups. For functional enrichment analysis FoldGO uses TopGO package

### Functional annotation

#### Custom annotaion

For custom annotation one have to provide GO id -> Gene id list. One of the common formats for gene annotation is GAF. 
FoldGO provides simple and convinient parser for annotation presented in GAF format. 
```{r gafread, warning = FALSE, message = FALSE}
gaf_path <- system.file("extdata", "gene_association.tair", package = "FoldGO")
gaf <- GAFReader(file = gaf_path)
```

One can retrieve direct annotations with some meta information and version of GAF file using following methods:

```{r gaf_getters chunk 1, warning = FALSE, message = FALSE}
getVersion(gaf)
```

```{r gaf_getters chunk 2, eval = FALSE}
getAnnotation(gaf)
```

and retrieve direct annotations as list object:

```{r converttolist, eval = FALSE}
gaf_list <- convertToList(gaf)
```

To annotate our gene groups we will use FuncAnnotGroupsTopGO function which uses topGO package for singular enrichment analysis.
The minimal set of arguments needed for this function to work is:

* groups - object of GeneGroups class 
* namespace - character string specifing GO namespace. This argument accepts following values: "BP", "MF" or "CC", where 
    * BP - biological process
    * MF - molecular function
    * CC - cellular component
* GO2genes - from topGO manual: named list of character vectors.  The list names are GO identifiers. For each GO the character vector contains the genes identifiers which are mapped to it.
* annot - functions used to compile a list of GO terms such that each element in the list is a character vector containing all the gene identifiers that are mapped to the respective GO term. Here it must be assigned with topGO::annFUN.GO2genes
* bggenes - vector contains background set of genes

```{r annot, warning = FALSE, message = FALSE, eval = FALSE}
library(topGO)
annotobj <- FuncAnnotGroupsTopGO(genegroups = up_groups, namespace = "MF", GO2genes = gaf_list, annot = topGO::annFUN.GO2genes, bggenes = bggenes)
```

#### Using annFUN.org db annotaions

Another possibility is to use bioсonductor packages containing annotations for specific organism. For example "org.Hs.eg.db"" (Human) and "org.Mm.eg.db" (Mouse), package name must be assigned to `mapping` argument. In this case one have to assign `topGO::annFUN.org` to annot argument. Specify `ID` - From topGO package manual: character string specifing the gene identifier to use. Currently only the following identifiers can be used: `c("entrez", "genbank", "alias", "ensembl", "symbol",     "genename", "unigene")`.  

```{r human_annot, warning = FALSE, message = FALSE, eval = FALSE}
up_groups <- GeneGroups(degenes_hum, quannumber=6)
annotobj <- FuncAnnotGroupsTopGO(up_groups,"MF", mapping = "org.Hs.eg.db", annot = topGO::annFUN.org, ID = "ensembl", bggenes = bggenes_hum)
```

### Testing on fold-specificity

The fold-specificity recognition procedure consists of GO terms preselection from DEGs annotation and 
fold-change-specific enrichment analysis. On each step the FDR threshold must be established. 
By default FDR threshold for GO terms preselection (fdrstep1) is set to 1 (no preselection) and FDR threshold 
for fold-change-specific enrichment analysis (fdrstep2) is set to 0.05. As a default method for mutltiple testing correction FoldGO uses Benjamini-Hochberg correction procedure. It is possible choose another correction procedure 
from R base which can be listed via `p.adjust.methods`. 

```{r fs_test}
up_fsobj <- FoldSpecTest(up_annotobj, fdrstep1 = 0.05, fdrstep2 = 0.01)
down_fsobj <- FoldSpecTest(down_annotobj, fdrstep1 = 0.05, fdrstep2 = 0.01)
```

One can inspect the results of enrichment analysis as dataframes. Access dataframe with fold-specific terms: 
```{r}
fs_table <- getFStable(up_fsobj)
knitr::kable(head(fs_table), format = "html")
```

And with not fold-specific:
```{r}
nfs_table <- getNFStable(up_fsobj)
knitr::kable(head(nfs_table))
```

### Plot results 


```{r fs_plot, warning = FALSE, message = FALSE, fig.height = 10, fig.width = 7}
plot(up_fsobj, down_fsobj)
```



## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
